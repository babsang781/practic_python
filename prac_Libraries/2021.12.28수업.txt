2021.12.28 화 5교시

- np 복습
	- arr2.shape : 크기(2,3)/  arr2.size : 요소 개수 ( 6 ) / arr2.dtype :데이터 타입  (int32) / arr2.ndim : 차원 확인 ( 2)
- # ZEROS (배열의 크기)     np.zeros((3,2))  // 0으로 초기화 하는 것( 원래 임의값 있음)
- # full(배열의 크기, 채워넣을 값)    np.full((3,4),5)
---
- #1 부터 50까지 1씩 커지는 배열 만들기
#np.linspace(시작하는 수, 끝나는 수 , 등분할 값)
#같은 간격만큼의 배열을 만들 때 사용
np.linspace(1,50,50)
```
array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13.,
       14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26.,
       27., 28., 29., 30., 31., 32., 33., 34., 35., 36., 37., 38., 39.,
       40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50.])
```

- # np.linspace도 for 문처럼 쓸 수 있음. 
for i in  np.linspace(1,50,20):
    print(i,end=" \t" )
```
1.0 	3.5789473684210527 	6.157894736842105 	8.736842105263158 	11.31578947368421 	13.894736842105264 	16.473684210526315 	19.05263157894737 	21.63157894736842 	24.210526315789473 	26.789473684210527 	29.36842105263158 	31.94736842105263 	34.526315789473685 	37.10526315789474 	39.68421052631579 	42.26315789473684 	44.8421052631579 	47.421052631578945 	50.0 	
```

- #랜덤 값으로 배열 생성하기
#np.random.rand(배열의 크기)
# 0~1 사이의 값을 가지는 배열을 생성

np.random.rand(2,3)
```
array([[0.64246478, 0.70250807, 0.67510784],
       [0.82045562, 0.23961796, 0.35773537]])
```

- # 원하는 범위에 서 랜덤 값 생성
# np.random.randint(시작하는 수, 끝 범위의 수 +1, size =배열의 크기)
np.random.randint(2,10, size=(3,2))
```
array([[4, 3],
       [5, 2],
       [2, 4]])
```

- # 2 부터 10 까지의 랜덤한 실수값으로 이루어진 5,4 크기의 배열 생성
# *8+2
print(np.random.rand(5,4) *8 +2 )

# *1.0
print(np.random.randint(2,10, size=(5,4)) *1.0 )

# 실수= 정수 + 소수점 (쌤 방식)
print(np.random.rand(5,4)+np.random.randint(2,10, size=(5,4)))
```
[[5.13364866 5.4079425  4.31164587 6.17117499]
 [8.64123858 3.00833237 8.63558174 7.04418267]
 [9.81207495 6.68818319 4.57023682 2.76917971]
 [9.78598703 5.92798143 3.7406599  8.94161026]
 [7.14597181 5.36534411 7.87664346 9.02287614]]
[[8. 7. 4. 7.]
 [3. 3. 6. 7.]
 [4. 9. 2. 3.]
 [5. 9. 7. 4.]
 [2. 7. 4. 3.]]
[[4.69256335 5.64294303 7.69286952 3.34568564]
 [7.57808314 9.99491991 9.70560729 6.34936081]
 [2.76622715 3.88679812 8.45937162 9.40176692]
 [5.49867851 2.28305187 6.6478102  6.71763067]
 [7.91584967 2.0192812  9.69188585 8.63375216]]
```

- # 타입 변경하기
# 배열.astype(변경할 타입)
arrx=np.random.rand(5,4) *8 +2
print(arrx)
print(arrx.astype('int'))  # 내림으로 처리하는 듯
```
[[9.34353378 5.20040224 7.69445484 6.62378925]
 [9.39650447 8.96846533 7.53775576 9.85036528]
 [7.66752012 7.75860389 9.16481866 2.73356859]
 [4.48303529 2.21668973 3.32435314 4.5460403 ]
 [8.90865309 7.03436549 8.27196039 2.76216517]]
[[9 5 7 6]
 [9 8 7 9]
 [7 7 9 2]
 [4 2 3 4]
 [8 7 8 2]]
```

---
(6교시)
### 배열의 기능 ###
arr = np.array([[1,2,3],[4,5,6]])
print(arr)
```
[[1 2 3]
 [4 5 6]]
```

# 다차원 배열의 indexing 인덱싱 [] : 고차원 배열 부터 지칭
print(arr[0])
# 2차원에서 1번째 선택 방법 2 가지
print(arr[0,1], arr[0][1])    # 둘 다 같음
```
[1 2 3]
2 2
```

# 0~ 9까지의 값이 담긴 배열 생성
arrx=np.random.randint(0,10, size=(1,9))
print(arrx)

# ...

arr1 = np.arange(10)
print(arr1)
```
[[5 9 5 4 4 5 1 6 8]]
[0 1 2 3 4 5 6 7 8 9]
```

- # 1차원 데이터를 2차원으로 바꿔주는 방법이 있음

- # 우선 0~49까지 정수값이 담긴 1차원 배열 생성
arr2 = np.arange(50)
- # arr2 를 (5,10)의 크기로 재 배열하기
# reshape( 배열의 행, 열 개수) 함수: 배열이 바뀌기 전 후의 데이터 수가 맞아야 함.
# 저장하는 기능은 없음. 출력만 가능
print(arr2.reshape(5,10))         # arr2=arr2.reshape(5,10)  # 변수 저장 별도
```
[[ 0  1  2  3  4  5  6  7  8  9]
 [10 11 12 13 14 15 16 17 18 19]
 [20 21 22 23 24 25 26 27 28 29]
 [30 31 32 33 34 35 36 37 38 39]
 [40 41 42 43 44 45 46 47 48 49]]
```

#시작 수 :끝 수 +1
# : 끝 수 +1
# 시작수 : 시작부터 끝까지
# 처음부터 끝까지
print(arr2[:5,0])
print(arr2[:5,:1])
print(arr2[:4,:5])
```
[ 0 10 20 30 40]    # print(arr2[:5,0])
[[ 0]               # print(arr2[:5,:1])
 [10]
 [20]
 [30]
 [40]]
[[ 0  1  2  3  4]   # print(arr2[:4,:5])
 [10 11 12 13 14]
 [20 21 22 23 24]
 [30 31 32 33 34]]
```

---
# 슬라이싱 인덱싱 실습 문제 height_weight.txt
# 파일 불러오기
data = np.loadtxt("height_weight.txt", delimiter = ',')
print(data)
```
[[175.2 180.3 175.  169.2 185.2 188.  177.6 178.2 177.  179. ]
 [ 65.6  88.   79.2  69.3  55.   71.2  73.   68.9  74.   82. ]]
```

data2 = np.zeros(data[0].size)

for i in range(data[0].size):
    data2[i] = data[1,i]/(data[0,i]/100)/(data[0,i]/100)
print(data2)
```
[21.37153104 27.07018468 25.86122449 24.20652885 16.03543423 20.14486193
 23.14392095 21.69720651 23.62028791 25.59220998]
```
data2x = []

for i in range(data[0].size):
    data2x.append(data[1,i]/(data[0,i]/100)/(data[0,i]/100))
print(data2x)
```
[21.371531035633122, 27.070184683258837, 25.86122448979592, 24.206528846637493, 16.03543422789676, 20.144861928474423, 23.143920947975, 21.697206508280217, 23.620287912158062, 25.592209980961893]
```
print("data[0].size : ",data[0].size), 
print("data[:,0].size : ",data[:,0].size)
print(f'array data is ({data[:,0].size},{data[0].size})')
```
data[0].size :  10
data[:,0].size :  2
array data is (2,10)
```

# 쌤 방식, 배열의 특정 행에 연산한 값을 변수로 저장하고, 그것들끼리 계산
키m = data[0]/100
몸무게= data[1]

몸무게 / (키m * 키m)
```
array([21.37153104, 27.07018468, 25.86122449, 24.20652885, 16.03543423,
       20.14486193, 23.14392095, 21.69720651, 23.62028791, 25.59220998])
```

---
# 또 다른 인덱싱 방법 : boolean indexing
# True는 출력하고 False 는 출력하지 않음
# 인덱싱을 진행할 때 값의 개수와 동일한 수의 불리언 데이터 필요####***
arr3 = np.array([10,20,15,30])
bol = np.array([True, False, True, False])
print(arr3[bol])
```
[10 15]
```

# 데이터를 살펴보지 않고도, 내가 원하는 조건에 따른 값만 확인할 수 있음.
arr3[arr3<17], arr3[arr3==20]
```
(array([10, 15]), array([20]))
```

---
# numpy 에서 사용하는 연산 함수
#1~9 까지의 랜덤한 수가 담긴 2,5 크기의 배열 생성

arr4 = np.random.randint(1,10,size=(2,2,3))
```
array([[[3, 5, 8],
        [5, 5, 2]],

       [[6, 7, 7],
        [4, 6, 5]]])
```

# np.sum(배열값) : 배열 안에 있는 값 더하기, axis: 중심선
print(np.sum(arr4, axis = 1))
print(np.sum(arr4, axis = 0))
print(np.sum(arr4, axis = 2))
```
[[ 8 10 10]
 [10 13 12]]
[[ 9 12 15]
 [ 9 11  7]]
[[16 12]
 [20 15]]
```

# np.mean(배열값) : 배열 안에 있는 값의 평균, axis 동일하게 씀
print(np.mean(arr4, axis = 1))
print(np.mean(arr4, axis = 0))
print(np.mean(arr4, axis = 2))
```
[[4.  5.  5. ]
 [5.  6.5 6. ]]
[[4.5 6.  7.5]
 [4.5 5.5 3.5]]
[[5.33333333 4.        ]
 [6.66666667 5.        ]]
```

---
(8교시)
실습 ## 영화 평점 데이터 분석하기
- # 데이터 타입 변경 하여 불러오기 
- # dtype  # 데이터 형태 -'id :: 영화 번호 :: 평점 :: (타임스탬프)'
data = np.loadtxt('ratings.txt', delimiter="::", dtype = 'int')    
# :: 으로 구분된 txt 파일, int 형으로 변환하여 불러오기
print(data) 데이터가 100만 개 여서 조금 걸렸음

# 각 사용자별 평점 평균 구하기
# 리스트에 [사용자, 사용자의 평점 평균] 형태로 저장할 것
user_list=[]   # 새로 저장할 배열 생성
for i in range(1, 6041):     # 회원 id 수 만큼 반복 범위 지정
    temp = data[ data[:,0] == i ]     # 각 회원마다 영화 평점 배열을 임시변수에 저장
    user_list.append([i, np.mean(temp[:, 2])])   # id와 평균 평점을 배열형태로 추가

print(list_rating)
--

# 각 사용자별 평균 평점이 4점 이상인 사용자 구하기

user_RatingOver4=[]   # 평균 평점 4점 이상인 회원 모을 리스트 생성

for i in range(0,6040):     # 회원 수만큼 반복

    # 4 가 넘는지 검사하고 list에 회원 id 입력
    if user_list[i][1] >=4:
        user_RatingOver4.append(i+1)     # 회원 아이디 1 = 인덱스 0 이라서 +1 

print(user_RatingOver4)
